\ Information                                                                                                                   NEWAPP is a skeletal program that allows users to quickly       develop a DOS application. It provides often needed tasks       including error handling, command-line parsing, file            operations, buffered I/O, help screen, number and string        functions.                                                                                                                      NEWAPP comprises two parts:                                                                                                       NEWAPP.SCR   skeletal application program                       DOSLIB.SCR   function support library                                                                                                                                                                                                                                                                                         \ Module loader                                                                                                                 cr ." DOSLIB  2022-01-11 " cr                                                                                                   base @  sys @  decimal  system                                                                                                  -? loadfile -path 2constant lib                                                                                                 -? : MODULE  2constant does> 2@ lib loaded ;                                                                                    2 load  behead lib module                                                                                                       sys !  base !                                                                                                                                                                                                                                                   \ Directory                                                      5 6    module _Errors          \ error handler                  7 dup  module _Inout1          \ number output                  8 dup  module _Inout2          \ number output                  9 dup  module _Inout3          \ deferred output                10 dup module _Compare1        \ basic compare                  11 13  module _String1         \ basic strings                  14 dup module _String2         \ extra strings                  15 20  module _Parsing1        \ command-line parsing           21 dup module _Parsing2        \ command-line parsing           22 24  module _Fileprims       \ file primitives                25 33  module _Files           \ default files                  34 dup module _Bufinfile       \ buffered input file            35 dup module _Bufoutfile      \ buffered output file          -->                                                                                                                             \ Directory                                                      36 dup module _Random          \ random numbers                 37 dup module _Shuffle         \ shuffle cells                  38 dup module _Qsort           \ quicksort cells                39 dup module _Dos1            \ dta                            40 dup module _Dos2            \ ctl-brk int                    41 dup module _Disk            \ disk                           42 dup module _Memory          \ memory allocate                43 44  module _Timedate1       \ time/date                      45 dup module _Timedate2       \ time/date                      46 dup module _Timepack        \ time/date packing              47 48  module _Filematch       \ file find first/next           49 dup module _Wildexp         \ file wildcard expander         50 dup module _Filestamp       \ file stamp/attribute           51 dup module _Diskdir         \ directory                     -->                                                             \ Directory                                                      52 dup module _Env             \ environment                    53 55  module _Exec            \ exec prog/command              56 57  module _Video1          \ textcolor attrib cursor        58 dup module _Video2          \ mode page                      59 dup module _Timing1         \ timer                          60 dup module _Timing2         \ delay                          61 dup module _Timing3         \ timer0 mode                    62 63  module _Device1         \ 8087 cpu keybd                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \ Errors: +IS ?THROW ?CATCH                                     system                                                          \ Add new behaviour to existing deferred word                   : +IS ( xt <name> -- )  >r  :noname  r> compile,                  ' >body  dup >r  @ compile,  postpone ;  r> ! ;               application                                                                                                                     \ THROW exception code n if flag is non-zero                    : ?THROW ( flag n -- )  swap 0<> and throw ;                                                                                    \ Perform CATCH intercepting exception code n only              : ?CATCH ( xt n -- n )  >r catch dup r> <> over and throw ;                                                                                                                                                                                                                                                                     \ Errors: .ABORT STOPKEY= STOPKEY? ?STOPKEY                     \ Quit to DOS with abort msg and return code = 1                : .ABORT ( -- )  ."  ... aborting"  abort ;                                                                                     \ Test char for ESC or Ctrl-C                                   : STOPKEY= ( char -- flag )  dup #27 =  swap 3 =  or ;                                                                          \ Test key and return true if stopkey                           : STOPKEY? ( -- flag )  key? if  key stopkey=  end  0 ;                                                                         \ Test key and confirm abort if stopkey                         : ?STOPKEY ( -- )  stopkey? if  beep cr                             ." User break - exit program? "  y/n  if  .abort  then        then ;                                                                                                                                                                                        \ Inout1: (UD.) UD. UD.R (DH.N) (DH.) (HW.) (HB.) DH. HW. HB.   : (UD.) ( ud -- addr u )  <# #s #> ;                            : UD.   ( ud -- )  (ud.) type space ;                           : UD.R  ( ud +n -- )  >r (ud.) r> s.r ;                                                                                         : (DH.N) ( ud n -- )                                              base @ >r hex <# 0 do # loop #> r> base ! ;                   : (DH.) ( ud -- a u )  4 cells (dh.n) ;                         : (HW.) ( u -- a u )  0 4 (dh.n) ;                              : (HB.) ( u -- a u )  0 2 (dh.n) ;                              : DH.   ( ud -- )  (dh.) type space ;                           : HW.   ( u -- )  (hw.) type space ;                            : HB.   ( u -- )  (hb.) type space ;                                                                                                                                                                                                                            \ Inout2:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \ Inout3: #OUT >EMIT >TYPE >CR >SPACE >SPACES                   \ Deferred output                                               variable #OUT                                                   defer >EMIT ( c -- )                                            : >TYPE   ( a u -- )  bounds ?do  i c@ >emit  loop ;            : >CR     ( -- )      (cr) >type  #out off ;                    : >SPACE  ( -- )      bl >emit ;                                : >SPACES ( n -- )    0 max 0 ?do  >space  loop ;                                                                               \\ set output to buffered disk                                  :noname  writechar  1 #out +! ;  is >emit                                                                                                                                                                                                                                                                                                                                                       \ Compare1: DIGIT? ALPHA?                                       \ Return true if char is decimal digit                          : DIGIT? ( char -- flag )  [char] 0 - #10 u< ;                                                                                  \ Return true if char is alphabetical                           : ALPHA? ( char -- flag )  upcase [char] A - #26 u< ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \ String1: SPLIT /SPLIT STRING/                                 \ Split string at character leaving first on top                : SPLIT ( a u c -- a2 u2 a3 u3 )                                  >r 2dup r> scan 2swap 2 pick - ;                                                                                              \ Split string at index n leaving first on top:                 \ >r over r@ 2swap r> /string 2swap                             code /SPLIT ( a u n -- a2 u2 a3 u3 )  ax pop  sp bx mov           2 [bx] push  ax 0 [bx] sub  ax 2 [bx] add  1push  end-code                                                                    \ Return u right-most characters of string:  >r + r@ - r>       code STRING/ ( a1 u1 u -- a2 u2 )  ax pop  bx pop  dx pop         bx dx add  ax dx sub  2push  end-code                                                                                                                                                                                                                         \ String1: C+STRING STRING/C S=                                 \ Append character to end of string:  2dup 2>r + c! 2r> 1+      code C+STRING ( c a u -- a2 u2 )  cx pop  bx pop  ax pop          bx push  cx bx add  cx inc  cx push  al 0 [bx] mov  next      end-code                                                                                                                        \ Extract character from end of string:  1- 2dup + c@           code STRING/C ( a u -- a2 u2 c )  cx pop  bx pop  cx dec          bx push  cx push  cx bx add  0 # ah mov  0 [bx] al mov          1push  end-code                                                                                                               \ Compare two strings for equality                              : S= ( a1 u1 a2 u2 -- flag )  compare 0= ;                                                                                                                                                                                                                      \ String1: RJUST (S.R)                                          \ Return string right-aligned as a2 u2. Uses HOLD buffer        : RJUST ( a u +n c -- a2 u2 )                                     >r >r  <# 2dup shold #>  r> over - 0 max  r> nhold #> ;                                                                       : (S.R) ( a u +n -- a2 u2 )  bl rjust ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         \ String2: S+ SVAR S!                                           #255 ( buffer size )  -? create sb  dup , allot                                                                                 \ Concatenate two strings placing result in temp buffer         : S+ ( a1 u1 a2 u2 -- a3 u3 )  2>r  sb @ umin  sb cell+ 0         +string  sb @  over -  2r> rot min  2swap +string ;           behead sb sb                                                    \ Define string variable with max length u                      -? : SVAR  create ( u -- )  #255 min dup c, 0 c, allot            does> ( -- sa su )  1+ count ;                                                                                                \ Store string a u to string variable                           : S! ( a u sa su -- )  drop  1- dup >r  1- c@ umin  r> place ;                                                                                                                                                                                                  \ Parsing1: ARGC /ARG !ARG ARGV                                 create ARGC ( -- a )  3 cells allot                                                                                             \ Reset parser to beginning                                     : /ARG ( -- )  argc off ;                                                                                                       \ Assign string for parsing                                     : !ARG ( a u -- )  argc cell+ 2!  /arg ;  here 0 !arg                                                                           \ Parse next blank delimited argument                           : ARGV ( -- a u -1 | 0 )                                          1 argc +!  argc cell+ 2@  0 0                                   argc @  0 ?do                                                     2drop  bl skip  bl split                                      loop  2nip                                                      dup if  -1  end  and ;                                        \ Parsing1: BADOPTION ?BADOPTION /DNUM /NUM /HEXNUM /NUMRANGE   : BADOPTION ( -- )  cr ." Invalid option"  .abort ;             : ?BADOPTION ( f -- )  0= if badoption then ;                                                                                   \ Parse number d|ud from string                                 : /DNUM ( a u -- a' 0 d|ud )                                      number?  ?badoption  here 0 ( stop parsing)  2swap ;                                                                          : /NUM ( a u -- a' 0 n|u )  /dnum drop ;                                                                                        \ Parse hex number n|u from string                              : /HEXNUM ( a u -- a' 0 n|u )  base @ >r  hex /num  r> base ! ;                                                                 \ /NUM with range check                                         : /NUMRANGE ( a u n|u1 n|u2 -- a' 0 n|u3 )                        2>r  /num  dup 2r> between  ?badoption ;                      \ Parsing1: SETOPTION                                           \ Process each character in a switch option string              defer SETOPTION ( a u char -- a' u' )  ' drop is setoption                                                                      \\ Example of use                                               :noname ( a u char -- a' u' )                                     upcase [char] A = if  A-variable on  end                        badoption ;  is setoption                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \ Parsing1: PARSEOPTION                                         \ Parse multiple switch options from the command-line           : PARSEOPTION ( -- )                                              begin                                                             argv                                                          while ( not end )                                                 c/string                                                        $FD and  [char] -  ( '-' or '/')                                - if  2drop  -1 argc +! ( backup)  end                          begin  dup                                                      while  c/string setoption                                       repeat  2drop                                                 repeat ;                                                                                                                                                                                                                                                      \ Parsing1: PARSEFILENAME                                       \ Parse one or more strings/filenames from the command-line     defer PARSEFILENAME ( -- )  ' noop is parsefilename                                                                             \\ Example of use                                               :noname ( -- )                                                    argv 0= if ." no filename specified"  .abort  then              infile !fname ;  is parsefilename                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \ Parsing1: PARSECMD                                            \ Parse string setting options and filenames                    : PARSECMD ( a u -- )                                             !arg  parseoption  parsefilename ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \ Parsing2: FIRSTNUM NEXTNUM                                    \ Parse first number & true, or false if string empty           : FIRSTNUM ( a u -- a' u' n|u true | a 0 false )                  dup if  /number drop  -1  end  0 ;                                                                                            \ As FIRSTNUM but skip first character                          : NEXTNUM ( a u -- a' u' n|u true | a 0 false )                   dup if  1 /string  /number drop  -1  end  0 ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 \ Fileprims: ?FERROR                                            \ Display msg and abort on file error                           : ?FERROR ( ior err# -- )                                         swap if                                                           cr ." File "  cond                                                3  of  ." read"  else                                           4  of  ." write"  else                                          5  of  ." position"  else                                       6  of  ." size"  else                                           .                                                             cont  ."  error"  .abort                                      then  drop ;                                                                                                                                                                                                                                                                                                                  \ Fileprims: FREAD FWRITE FREADLN FWRITELN                      \ Read binary                                                   : FREAD ( a u fid -- a u2 )                                       ?stop  2>r dup 2r>  read-file  3 ?ferror ;                                                                                    \ Write binary                                                  : FWRITE ( a u fid -- )  ?stop  write-file  4 ?ferror ;                                                                         \ Read text  flag=0 if end-of-file                              : FREADLN ( a u fid -- a u2 flag )                                ?stop  2>r dup 2r>  read-line  3 ?ferror ;                                                                                    \ Write text                                                    : FWRITELN ( a u fid -- )  ?stop  write-line  4 ?ferror ;                                                                                                                                       \ Fileprims: FPOS FSEEK FSIZE FRESIZE                           \ Get file position                                             : FPOS ( fid  -- ud )  file-position  5 ?ferror ;                                                                               \ Reposition file                                               : FSEEK ( ud fid  -- )  reposition-file  5 ?ferror ;                                                                            \ Get file size                                                 : FSIZE ( fid  -- ud )  file-size  6 ?ferror ;                                                                                  \ Resize file                                                   : FRESIZE ( ud fid  -- )  resize-file  6 ?ferror ;                                                                                                                                                                                                                                                                              \ Files: HANDLE >FID !FNAME @FNAME .FNAME                       \ Create file handle                                            -? : HANDLE ( "name" -- ; -- handle )  create                     -1 , ( fid)  0 c, max-path allot ( filename) ;                                                                                aka @ >FID ( handle -- fid )  \ Get fid from handle; -1=closed                                                                  \ Assign filename to handle & mark as closed                    : !FNAME ( a u handle -- )  >r  -blanks                           max-path min  r>  dup on  cell+ pack  count upper ;                                                                           \ Get filename                                                  : @FNAME ( handle -- a u )  cell+ count ;                                                                                       \ Display filename                                              : .FNAME ( handle -- )  @fname type ;                           \ Files: ?OPENERR FOPEN (FOPEN)                                 : ?OPENERR ( handle ior -- )                                      dup if                                                            swap  cr .fname space  $FF and  cond                              2  of  ." file not found"  else                                 3  of  ." path not found"  else                                 4  of  ." too many open files"  else                            5  of  ." access denied"  else                                  .  ." open error"                                             cont  .abort                                                  then  2drop ;                                                                                                                 : FOPEN ( fam handle -- ior )                                     tuck  @fname rot open-file  tuck  0<> or  rot ! ;                                                                             : (FOPEN) ( fam handle -- )  tuck  fopen  ?openerr ;            \ Files: WRTCHK FMAKE (FMAKE) (?FMAKE)                          variable WRTCHK  wrtchk on          \ overwrite check                                                                           : FMAKE ( fam handle -- ior )                                     tuck  @fname rot create-file  tuck  0<> or  rot ! ;                                                                           : (FMAKE) ( fam handle -- )  tuck  fmake  ?openerr ;                                                                            : (?FMAKE) ( fam handle -- )                                      wrtchk @ if ( overwrite check )                                   dup @fname  r/o open-file  0= if                                  close-file  beep  cr  over .fname                               ."  exists - overwrite? "  y/n 0= if  .abort  then            then  drop                                                    then  (fmake) ;                                                                                                               \ Files: (?FOPEN) FCLOSE                                        \ Flag=true if file exists, zero if created                     : (?FOPEN) ( fam handle -- flag )                                 2dup fopen                 \ attempt file open                  if  (fmake)  false  end    \ attempt create                     2drop  true ;              \ success                                                                                          : FCLOSE ( handle -- ior )                                        dup >fid  swap on  -1 of  0  end  close-file ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \ Files: default handles                                        handle INFILE       \ input file handle                         handle OUTFILE      \ output file handle                                                                                        here value INBUF    \ buffer address                            #512 value #INBUF   \ buffer size                               variable INSIZ                                                  variable INPTR                                                                                                                  here value OUTBUF   \ buffer address                            #512 value #OUTBUF  \ buffer size                               variable OUTSIZ                                                 variable OUTPTR                                                                                                                 : /INBUF  ( -- )  inbuf inptr !  insiz off ;                    : /OUTBUF ( -- )  outbuf outptr !  outsiz off ;                 \ Files: OPENINFILE MAKEOUTFILE OPENOUTFILE ?OPENOUTFILE        \ Open file for input using file access mode                    : OPENINFILE ( fam -- )  infile (fopen)  /inbuf ;                                                                               \ Create file for output using file access mode                 : MAKEOUTFILE ( fam -- )  outfile (?fmake)  /outbuf ;                                                                           \ Open existing file for output using file access mode          : OPENOUTFILE ( fam -- )  outfile (fopen)  /outbuf ;                                                                            \ Open/create file for output using file access mode            \ Flag=true if file exists, zero if created                     : ?OPENOUTFILE ( fam -- flag )  outfile (?fopen)  /outbuf ;                                                                                                                                                                                                     \ Files: CLOSEINFILE CLOSEOUTFILE CLOSEFILES                    defer (flushwrite) ( -- ior )  ' false is (flushwrite)                                                                          \ Close input file - errors not reported                        : CLOSEINFILE ( -- )  infile fclose drop ;                                                                                      \ Close output file - errors not reported                       : CLOSEOUTFILE ( -- )                                             outfile  dup >fid 1+ if (flushwrite) drop then  fclose drop ;                                                                 \ Close files - errors not reported                             defer CLOSEFILES ( -- )                                                                                                         :noname ( -- )  closeinfile  closeoutfile ;  is closefiles                                                                      ' closefiles +is onerror  \ close files on error                \ Files: DELOUTFILE SEEKIN/OUTFILE POSIN/OUTFILE                \ Close and delete output file - errors not reported            : DELOUTFILE ( -- )  outfile  dup >fid  closeoutfile              if  @fname  delete-file  then  drop ;                                                                                         \ Reposition input file                                         : SEEKINFILE ( ud -- )  infile >fid fseek /inbuf ;                                                                              \ Reposition output file                                        : SEEKOUTFILE ( ud -- )  (flushwrite) 4 ?ferror                   outfile >fid fseek ;                                          \ Get input file position                                       : POSINFILE ( -- ud )  infile >fid fpos  insiz @  0 d- ;                                                                        \ Get output file position                                      : POSOUTFILE ( -- ud )  outfile >fid fpos  outsiz @  0 d+ ;     \ Files: READDATA WRITEDATA READTEXT WRITETEXT FLUSHWRITE       \ Read binary from input file                                   : READDATA ( a u1 -- a u2 )  infile >fid fread ;                                                                                \ Write binary to output file                                   : WRITEDATA ( a u -- )  outfile >fid fwrite ;                                                                                   \ Read text from input file  flag=0 if end-of-file              : READTEXT ( a u1 -- a u2 flag )  infile >fid freadln ;                                                                         \ Write text to output file                                     : WRITETEXT ( a u -- )  outfile >fid fwriteln ;                                                                                 \ Flush output file to disk                                     : FLUSHWRITE ( -- )  (flushwrite) 4 ?ferror                       outfile >fid flush-file 4 ?ferror ;                           \ Bufinfile: READCHAR                                           #inbuf reserve to inbuf  /inbuf                                                                                                 : refillread ( -- )  \ refill read buffer                         /inbuf  inbuf #inbuf readdata  insiz !  drop ;                                                                                \ Read char from buffered input                                 \ : READCHAR ( -- char -1 | 0 )  insiz @ 0= if refillread then  \  insiz @ if inptr @ c@ 1 inptr +! -1 insiz +! -1 end  0 ;                                                                     code READCHAR ( -- char -1 | 0 )  0 # insiz ) cmp                 1 $ jnz  c: refillread ;c  1 $:  ax ax sub  ax insiz ) cmp      2 $ jz  inptr ) di mov  0 [di] al mov  ax push  inptr ) inc     insiz ) dec  -1 # ax mov  2 $:  1push  end-code                                                                                                                                               \ Bufoutfile: WRITECHAR                                         #outbuf reserve to outbuf  /outbuf                                                                                              :noname ( -- ior )  \ flush write buffer                        outbuf outsiz @  outfile >fid write-file  /outbuf  ?stop ;      is (flushwrite)                                                                                                                 \ Write char to buffered output                                 \ : WRITECHAR ( char -- )  outsiz @ #outbuf = if (flushwrite)   \  4 ?ferror then  outptr @ c! 1 outptr +! 1 outsiz +! ;                                                                        code WRITECHAR ( char -- )  addr #outbuf ) ax mov                 outsiz ) ax cmp  1 $ jnz  c: (flushwrite) 4 ?ferror ;c          1 $:  ax pop  outptr ) di mov  al 0 [di] mov  outptr ) inc      outsiz ) inc  next  end-code                                                                                                  \ Random: RND RAND RANDOM                                       \ Multiply doubles. Signed or unsigned.                         : D* ( d|ud1 d|ud2 -- d|ud3 )                                     >r swap >r 2dup um* rot r> * + rot r> * + ;                                                                                   \ LCS generator using BCPL algorithm                                                                                            2variable RND  1. rnd 2!                                                                                                        \ Get random number                                             : RAND ( -- u )                                                   rnd 2@ #2147001325. d* #715136305. d+ tuck rnd 2! ;                                                                           \ Get random number between 0 and u-1                           : RANDOM ( u -- 0..u-1 )  rand um* nip ;                                                                                        \ Shuffle: SHUFFLE                                              \ Shuffle cells                                                                                                                 [undefined] RANDOM [if] _Random [then]                                                                                          : SHUFFLE ( adr count -- )                                        begin dup while >r                                                dup r@ random cells +                                           2dup @ swap @  rot ! over !                                     cell+  r> 1-                                                  repeat 2drop ;                                                                                                                                                                                                                                                                                                                                                                                \ Qsort: PRECEDES QSORT                                         \ Quicksort addr/cells (adapted from Wil Baden)                 defer PRECEDES ( x1 x2 -- f )  \ comparison                                                                                     -? : q ( lo hi -- )  2dup  over -  u2/                            [ -1 cells ] literal  and  + @ >r  2dup swap  begin               begin dup @  r@ precedes while cell+ repeat swap                begin r@ over @ precedes while cell- repeat swap                2dup u< not if  over @ over @  3 pick !  over !                   swap cell-  swap cell+  then  2dup u<                       until  rdrop  rot  2over 2over - + > if 2swap then              2dup u< if recurse else 2drop then                              2dup u< if recurse end  2drop ;                                                                                               : SORT ( adr siz -- )                                             dup if  1- cells over + q  end  2drop ;  behead q q           \ Dos1: GETDTA SETDTA                                           \ Get/set DMA address                                           : GETDTA ( -- seg offs )  $2F doscall  'ES @  'BX @ ;                                                                           : SETDTA ( seg offs -- )                                          'DX !  'DS !  $1A 'AH c!  $21 intcall ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \ Dos2: GETCBRK SETCBRK GETINT SETINT                           \ Get/set Ctrl-Brk   0=off 1=on                                 : GETCBRK ( -- n )  0 'AX c!  $33 doscall  'DX c@ ;             : SETCBRK ( n -- )  'DX c!  1 'AX c!  $33 doscall ;                                                                             \ Get/set interrupt                                             : GETINT ( n -- seg offs )                                        'AX c!  $35 doscall  'ES @  'BX @ ;                                                                                           : SETINT ( seg offs n -- )                                        $2500 or 'AX !  'DX !  'DS !  $21 intcall ;                                                                                                                                                                                                                                                                                                                                                   \ Disk: DISKFREE DISKSIZE GETDSK SELDSK RESETDISK               -? : dsk ( n reg -- d )                                           swap 'DX c!  $36 doscall  @  'AX @  um* 'CX @  1 m*/ ;                                                                        \ Get freespace/size/path on drive n  0=default 1=A 2=B etc     \ Errors not reported                                           : DISKFREE ( n -- d )  'BX  dsk ;                               : DISKSIZE ( n -- d )  'DX  dsk ;  behead dsk dsk                                                                               \ Get/select current drive  0=A 1=B etc                         : GETDSK ( -- dsk )  $19 doscall 'AX c@ ;                       : SELDSK ( dsk -- )  'DX c!  $0E doscall ;                                                                                      \ Reset drives - use before disk change.  Be aware DOS          \ and CP/M versions of this function work differently.          : RESETDISK ( -- )  $0D doscall ;                               \ Memory: GETMEM RELMEM SETMEM                                  \ Allocate u paragraphs of memory                               : GETMEM ( par -- seg|maxpar ior )                                'BX !  $48 doscall  doserr?                                     dup if  'BX  else  'AX  then  @  swap ;                                                                                       \ Free previously allocated memory                              : RELMEM ( seg -- ior )                                           'ES !  $49 doscall  doserr? ;                                                                                                 \ Resize previously allocated memory                            : SETMEM ( seg par -- maxpar ior )                                'BX !  'ES !  $4A doscall  'BX @  doserr? ;                                                                                                                                                                                                                   \ Timedate1: @TIME !TIME @DATE !DATE                            \ Get current time/date                                         : @TIME ( -- sec min hour )                                       $2C doscall  'DH c@  'CX c@  'CH c@ ;                                                                                         \ Set current time/date                                         : !TIME ( sec min hour -- ior )                                   'CH c!  'CX c!  'DH c!  0 'DX c!  $2D doscall  'AX c@ >ior ;                                                                  : @DATE ( -- day mon year )                                       $2A doscall  'DX c@  'DH c@  'CX @ ;                                                                                          : !DATE ( day mon year -- ior )                                   'CX !  'DH c!  'DX c!  $2B doscall  'AX c@ >ior ;                                                                                                                                             \ Timedate1: H:M:S D-M-Y M-D-Y Y-M-D                            \ Convert time to string                                        : H:M:S ( sec min hour -- addr u )  swap rot  <#                  2 0 do  0 # # 2drop  [char] : hold  loop  0 # #  #> ;                                                                         \ Convert date to string                                        : D-M-Y ( day mon year -- addr u )  <#  0 # # # #                 2 0 do  2drop  [char] - hold  0 # #  loop  #> ;                                                                               \ Convert date to string                                        : M-D-Y ( day mon year -- addr u )  rot swap d-m-y ;                                                                            \ Convert date to string                                        : Y-M-D ( day mon year -- addr u )  swap rot <#                   2 0 do  0 # # 2drop  [char] - hold  loop  0 # # # # #> ;                                                                      \ Timedate2: $MONTH D-MMM-Y                                     \ Convert month to string                                       : $MONTH ( n -- a u )                                             1- 3 *  s" JanFebMarAprMayJunJulAugSepOctNovDec" drop + 3 ;                                                                   \ Convert date to string                                        : D-MMM-Y ( day mon year -- a u )                                 <#  0 # # # # 2drop  [char] - hold  $month shold                [char] - hold  0 # #  #> ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \ Timepack: PACKTIME UNPACKTIME PACKDATE UNPACKDATE             \ Pack time in MSDOS format                                     : PACKTIME ( sec min hour -- time )  #11 lshift                   swap #63 and  5 lshift  or  swap 2/ #31 and  or ;                                                                             \ Unpack MSDOS format time                                      : UNPACKTIME ( time -- sec min hour )  dup #31 and                2*  swap 5 rshift  dup #63 and  swap 6 rshift ;                                                                               \ Pack date in MSDOS format                                     : PACKDATE ( day mon year -- date )  #1980 -                      9 lshift  swap #15 and  5 lshift  or  swap #31 and  or ;                                                                      \ Unpack MSDOS format date                                      : UNPACKDATE ( date -- day mon year )  dup #31 and                swap 5 rshift  dup #15 and  swap 4 rshift #1980 + ;           \ Filematch: FINDFIRST FINDNEXT                                 -? create nb  max-path 1+ allot                                                                                                 \ Find first matching file. Use default DTA                     : FINDFIRST ( a u attrib -- ior )                                 $80 setdma  'CX !  2dup >fname 1+ 'DX !                         2dup -path nip - nb pack count upper  $4E doscall  doserr? ;                                                                  \ Find next matching file                                       : FINDNEXT ( -- ior )  $4F doscall  doserr? ;                                                                                                                                                                                                                                                                                                                                                                                                                   \ Filematch: DTA.ATTR DTA.TIME DTA.DATE DTA.SIZE DTA.NAME       \ Matched file data. Assume default DTA.                        : DTA.ATTR ( -- attrib )  [ $80 $15 + ] literal c@ ;            : DTA.TIME ( -- time )    [ $80 $16 + ] literal @ ;             : DTA.DATE ( -- date )    [ $80 $18 + ] literal @ ;             : DTA.SIZE ( -- ud )      [ $80 $1A + ] literal 2@ swap ;       : DTA.NAME ( -- addr u )  [ $80 $1E + ] literal zcount            nb count +string ;                                                                                                            behead nb nb                                                                                                                                                                                                                                                                                                                                                                                                                                                    \ Wildexp: FNAMES FINDALL +FNAME /FNAMES                        [undefined] FINDFIRST [if] _Filematch [then]                                                                                    create FNAMES ( -- adr )  here , ( current)  here , ( top)                                                                      \ Build a list of filenames at HERE matching adr u.  ior=none   : FINDALL ( adr u attrib -- ior )                                 findfirst  dup if end  ( 0)  here dup fnames 2!                 begin  dta.name s,  findnext until  0 c, ;                                                                                    \ Get next filename from list                                   : +FNAME ( -- adr u true | false )                                fnames @ count  dup if  2dup + fnames !  -1  end  nip ;                                                                       \ Reset +FNAME to point to first filename in list               : /FNAMES ( -- )  fnames cell+ @ fnames ! ;                     \ Filestamp: @FILESTAMP !FILESTAMP @FILEATTR !FILEATTR          \ Get disk file packed timestamp                                : @FILESTAMP ( fid -- date time ior )                             'BX !  0 'AX c!  $57 doscall  'DX @  'CX @  doserr? ;                                                                         \ Set disk file packed timestamp                                : !FILESTAMP ( date time fid -- ior )                             'BX !  'CX !  'DX !  1 'AX c!  $57 doscall  doserr? ;                                                                         \ Get disk file attributes                                      aka file-status @FILEATTR ( a u -- attrib ior )                                                                                 \ Set disk file attributes                                      : !FILEATTR ( attrib a u -- ior )                                 >fname 1+ 'DX !  'CX !  1 'AX c!  $43 doscall  doserr? ;                                                                      \ Diskdir: CHDIR MKDIR RMDIR                                    -? : dir ( a u fn -- ior )                                        -rot  >fname 1+ 'DX !  doscall  doserr? ;                                                                                     \ Directory change/make/remove                                  : CHDIR ( a u -- ior )  $3B dir ;                               : MKDIR ( a u -- ior )  $39 dir ;                               : RMDIR ( a u -- ior )  $3A dir ;  behead dir dir                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \ Env: ENVSEG GETENV                                            \ Return DOS environment segment                                : ENVSEG ( -- seg )  $2C @ ;                                                                                                    \ Search DOS environment for string a u.  Return null           \ terminated remainder.  Null not included in count.            : GETENV ( a u -- seg zadr len true | false )                     2>r  envseg  dup sseg !                                         0  begin  2dup @l  while  1+  repeat  2+                        r@  0  rot  2r>  caps search                                    if  rot /string  drop zcount  true                              else  2drop 2drop  0  then  cseg sseg ! ;                                                                                                                                                                                                                                                                                     \ Exec:                                                         [undefined] GETDTA [if] _Dos1 [then]                            [undefined] GETENV [if] _Env  [then]                            warning @  warning off                                          create pb  #14  allot  \ parameter block                        create ct  #128 allot  \ command tail                           create f1  #37  allot  \ fcb1                                   create f2  #37  allot  \ fcb2                                                                                                   : fcb! ( zadr fcb  -- zadr' )                                     'DI !  'SI !  cseg 'ES !  1 'AX c!  $29 doscall  'SI @ ;                                                                      : !fcb ( -- )                                                     ct 1+  f1 fcb!  f2 fcb! drop                                    cseg f1 [ pb #6 + ]  literal 2!                                 cseg f2 [ pb #10 + ] literal 2! ;                             \ Exec:                                                         : (exec) ( a u seg zadr flag -- ior )                             getdta 2>r                                                      >r  2swap                                                       pb 14 erase  cseg ct [ pb 2+ ] literal 2!                       ct 1+ 0  2 pick  r@ and if  s" /C "  2swap +string  then        +string  dup ct c!  + $0D swap c!                               r> 0= if !fcb then                                              'DX !  'DS !  pb 'BX !  cseg 'ES !  $4B00 'AX !                 $21 intcall  doserr?                                            2r> setdta ;                                                                                                                  warning !                                                                                                                                                                                                                                                       \ Exec: EXEC SHELL RETCODE                                      \ Execute program                                               : EXEC ( param u prog u -- ior )                                  >fname 1+  cseg swap  false (exec) ;                                                                                          \ Shell to DOS with optional command                            : SHELL ( a u -- ior )                                            s" COMSPEC=" getenv and                                         if  true (exec)  end  drop  #255 >ior ;                                                                                       \ Get subprocess return code                                    : RETCODE ( -- type code )                                        $4D doscall  'AH c@  'AX c@ ;                                                                                                 behead pb (exec)                                                                                                                \ Video1: text colors                                           0  constant BLACK       1  constant BLUE                        2  constant GREEN       3  constant CYAN                        4  constant RED         5  constant MAGENTA                     6  constant BROWN       7  constant LTGRAY                      8  constant GRAY        9  constant LTBLUE                      #10 constant LTGREEN    #11 constant LTCYAN                     #12 constant LTRED      #13 constant LTMAGENTA                  #14 constant YELLOW     #15 constant WHITE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \ Video1: BORDER HI -HI BLINK -BLINK @CURSOR !CURSOR -CURSOR    \ Set text border color                                         : BORDER ( n -- )  'BX !  $B00 'AX !  $10 intcall ;                                                                             \ Set video attribute                                           -? : xa  ( and or -- )  attrib c@  or and  attrib c! ;          : HI     ( -- )  $FF $08 xa ;                                   : -HI    ( -- )  $F7 0   xa ;                                   : BLINK  ( -- )  $FF $80 xa ;                                   : -BLINK ( -- )  $7F $00 xa ;  behead xa xa                                                                                     \ Cursor get/set/disable                                        : @CURSOR ( -- x )  $F00 'AX !  $10 intcall  $300 'AX !           $10 intcall  'CX @ ;                                          : !CURSOR ( x -- )  'CX !  $100 'AX !  $10 intcall ;            : -CURSOR ( -- )  $2000 !cursor ;                               \ Video2: @VMODE !VMODE @VPAGE !VPAGE                           \ Get/set video mode                                            : @VMODE ( -- n )  $F00 'AX !  $10 intcall  'AX c@ ;            : !VMODE ( n -- )  $FF and 'AX !  $10 intcall ;                                                                                 \ Get/set active video page                                     : @VPAGE ( -- n )  $F00 'AX !  $10 intcall  'BH c@ ;            : !VPAGE ( n -- )  dup $106 c!  $500 + 'AX !  $10 intcall ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \ Timing1: /TIMER TIMER TICKS>MS .TIMER                         \ Get BIOS ticks  1 tick = 54.9254 mS                           aka ticks /TIMER ( -- d )  \ Reset timer                                                                                        \ Get elapsed time in ticks (24 hours max)                      : TIMER ( d1 -- d2 )  ticks  2swap d-  dup 0< if                  ( cross midnight)  #1573040. d+  then ;                                                                                       \ Convert ticks to milliseconds                                 : TICKS>MS ( d1 -- d2 )  #14006 #255 m*/ ;                                                                                      \ Display elapsed time in milliseconds                          : .TIMER ( d -- )  timer ticks>ms <# #s #> type ."  mS " ;                                                                                                                                                                                                      \ Timing2: (USEC) USEC                                          \ Wait AL * 0.8381uS  Uses Timer 2                              label (USEC)  \ AL = 127 max                                      al ah mov  $61 # al in  $FC # al and                            1 # al or  here 2+ ju  al $61 # out                             pushf  cli  $90 # al mov  al $43 # out                          $61 # al in  ah al mov  al $42 # out                          1 $:  $61 # al in  $80 # al mov  al $43 # out                     $61 # al in  $42 # al in  al shl  1 $ jnc                       popf  ret  end-code                                                                                                           \ Wait u * 0.8381uS  Uses Timer 2                               code USEC ( u -- )  \ u = 127 max                                 ax pop  (usec) ) call  next  end-code                                                                                                                                                         \ Timing3: @TICKMODE !TICKMODE                                  \ Note: use /MS to recalibrate MS SOUND BEEP after changing     \ system tick timer mode                                                                                                        \ Get tick timer mode                                           : @TICKMODE ( -- 2|3 )  /ms  sys-vec #30 + @ ;                                                                                  \ Set tick timer mode  3=IBM-PC, 2=Win31/XP/other               : !TICKMODE ( n -- )  dup 2 or 3 = if                               2*  $30 +  $43 wait-tick pc!  $FF $40 pc!  $FF $40 pc!        end  drop ;                                                                                                                                                                                                                                                                                                                                                                                   \ Device1: 8087? CPU?                                           \ Test/init 80x87                                               code 8087? ( -- flag )                                            ax ax sub  ax push  sp bp xchg  $E3DB , ( FINIT )               #100 # cx mov  1 $: 1 $ loop  $7ED9 , 0 c, ( FSTCW [BP] )       sp bp xchg  bx pop  bx bx or  2 $ jz  ax dec  2 $:  1push     end-code                                                                                                                        \ Get CPU type                                                  code CPU? ( -- n )  \ n= $86, $286, $386                          pushf  $86 # ax mov  sp push  bx pop  bx sp cmp  1 $ jnz        2 # ah mov  pushf  bx pop  $F0 # bh or  bx push  popf  pushf    bx pop  $F0 # bh and  1 $ jz  ah inc  1 $:  popf  1push       end-code                                                                                                                                                                                        \ Device1: EH-KEYBOARD?                                         \ Enhanced keyboard hardware test                               : EH-KEYBOARD? ( -- flag )                                        $40 $96 c@l  $10 and  0<> ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   