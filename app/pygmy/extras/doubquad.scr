( This file contains the code for DOUBLE and QUAD number          support )                                                                                                                     ( copyright 1990-2007  Frank Sergeant                            License:  See license20040130.txt or                                      http://pygmy.utoh.org/license.html                                                                                   ( Note the shift operators << and >> conflict with the assembler"preview" operators.  Change names of one or the other if you   want both available at the same time.)                                                                                                                                                                                                                                                                                                                                                                                                                          ( load screen for DOUBLES & QUADS )                             4002 4024 THRU  ( doubles )                                     4025 4048 THRU  ( quads   )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( perhaps these should go in kernel sometime     )              : UMAX ( a b - max) 2DUP U< IF SWAP THEN DROP ;                                                                                 : N# ( n -) <# #S #> ; ( type converted number as ascii str)                                                                    : 0.R ( u # -) ( print # places even if leading zeroes)           PUSH <# POP  FOR # NEXT #> ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( multi-precision return stack operators )                       CODE 2PUSH ( u u -)  AX POP, SWITCH, BX PUSH, AX PUSH, SWITCH,    BX POP, NXT, END-CODE                                         CODE 2POP  ( - u u)  BX PUSH, SWITCH, AX POP, BX POP, SWITCH,     AX PUSH, NXT, END-CODE                                        CODE 3PUSH ( u u u -)  AX POP, CX POP, SWITCH,                    BX PUSH, AX PUSH, CX PUSH, SWITCH, BX POP, NXT, END-CODE      CODE 3POP  ( - u u u) BX PUSH, SWITCH, AX POP, CX POP,            BX POP, SWITCH,  AX PUSH, CX PUSH,  NXT, END-CODE             CODE 4PUSH ( u u u u -) AX POP, CX POP, DX POP, SWITCH,           BX PUSH, AX PUSH, CX PUSH, DX PUSH, SWITCH, BX POP,             NXT, END-CODE                                                 CODE 4POP ( - u u u u) BX PUSH, SWITCH, AX POP, DX POP,           CX POP, BX POP, SWITCH, AX PUSH, DX PUSH, CX PUSH, NXT,         END-CODE                                                                                                                     ( multi-precision return stack operators )                       CODE 8PUSH ( ... -) AX POP, CX POP, DX POP, SWITCH,               BX PUSH, AX PUSH, CX PUSH, DX PUSH, SWITCH,                     BX POP,  AX POP, CX POP, DX POP, SWITCH,                        BX PUSH, AX PUSH, CX PUSH, DX PUSH, SWITCH, BX POP,            NXT, END-CODE                                                                                                                  CODE 8POP ( - ...) BX PUSH, SWITCH,                               AX POP, DX POP,  CX POP, BX POP, SWITCH,                        AX PUSH, DX PUSH, CX PUSH, BX PUSH, SWITCH,                     AX POP, DX POP,  CX POP, BX POP, SWITCH,                        AX PUSH, DX PUSH, CX PUSH, NXT,                                END-CODE                                                                                                                                                                                                                                                      ( multi-precision stack operators )                             : 2SWAP ( al ah bl bh - bl bh al ah) ROT PUSH ROT POP ;         : 2OVER ( a b  x y - a b  x y  a b) 2PUSH 2DUP 2POP 2SWAP ;     : 3DUP ( ud n - ud n ud n)  PUSH 2DUP POP DUP 2SWAP ROT ;       : 3SWAP ( a b c  x y z - x y z  a b c) PUSH ROT  PUSH             ( a b  x y ) 2SWAP ( x y  a b) 2POP SWAP PUSH                   ( x y  a b  z)  ROT ROT POP ;                                 : 3OVER ( a b c  x y z - a b c  x y z  a b c) 3PUSH               3DUP  3POP  3SWAP  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ( multi-precision stack operators )                             : 4DUP ( a b c d - a b c d  a b c d)  2OVER 2OVER ;             CODE 4SWAP   ( 12 10 8 6  4 2 0  bx)                                         (  a  b c d  w x y  z  -  w x y z  a b c d)          SWITCH,                                                         6 [BP] AX MOV, BX 6 [BP] MOV, AX BX MOV, ( swap d & z)          8 [BP] AX MOV, 0 [BP] CX MOV, AX 0 [BP] MOV, CX 8 [BP] MOV,    10 [BP] AX MOV, 2 [BP] CX MOV, AX 2 [BP] MOV, CX 10 [BP] MOV,   12 [BP] AX MOV, 4 [BP] CX MOV, AX 4 [BP] MOV, CX 12 [BP] MOV,   SWITCH,  NXT,  END-CODE                                        : 4DROP ( a b c d - )  2DROP 2DROP ;                            : 4OVER ( 1 2 3 4 a b c d - 1 2 3 4 a b c d 1 2 3 4 )             4PUSH 4DUP 4POP 4SWAP ;                                       : 8DUP  ( 1 2 3 4 5 6 7 8 - 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 )     4OVER 4OVER ;                                                                                                                 ( DOUBLE comparisons)                                           CODE DU< ( ud ud - f) AX POP, ( top dbl is in BX&AX)             DX POP, CX POP, ( 2nd dbl is in DX&CX) AX CX SUB,  BX DX SBB,   BX BX SBB,   NXT, END-CODE                                     CODE DU> ( ud ud - f) AX POP, ( top dbl is in BX&AX)             DX POP, CX POP, ( 2nd dbl is in DX&CX) CX AX SUB,               DX BX SBB,  BX BX SBB,   NXT, END-CODE                         CODE D> ( d d - f) AX POP, DX POP, CX POP, CX AX SUB, DX BX SBB,  0 #, BX MOV,   <, IF, BX DEC, THEN,  NXT,  END-CODE           CODE D< ( d d - f) AX POP, DX POP, CX POP, AX CX SUB, BX DX SBB,  0 #, BX MOV,   <, IF, BX DEC, THEN,  NXT,  END-CODE                                                                           : D= ( l h  l h - f) ROT = PUSH = POP AND ;                     : D0= ( nd - f) OR 0= ;                                         : D0< ( nd - f) NIP 0< ;                                                                                                        ( DOUBLE math )                                                 CODE D2/  ( ud - ud/2)                                            AX POP, 1 #, BX SHR,  1 #, AX RCR,  AX PUSH,  NXT,  END-CODE                                                                  CODE UM* ( u u - d)                                               AX POP,  BX MUL,  AX PUSH,  DX BX MOV,  NXT,   END-CODE                                                                       CODE UM/ ( l h u - u )                                            DX POP,  AX POP,  BX DIV,  AX BX MOV,   NXT,   END-CODE                                                                       : 2, ( lo hi -)  , , ; ( not exactly math but what the hell)    : 2VARIABLE   VARIABLE 0 , ;                                                                                                                                                                                                                                                                                                    (                continued )                                    CODE D+ ( d d - d)     AX POP,  ( top # in BX&AX)                 DX POP, CX POP, ( 2nd in DX&CX)                                 CX AX ADD, DX BX ADC,  AX PUSH,   NXT,  END-CODE                                                                              CODE D- ( d d - d)   BX DX MOV,  CX POP,  ( top # in DX&CX)       BX POP, AX POP, ( 2nd in BX&AX)                                 CX AX SUB, DX BX SBB,  AX PUSH,   NXT,  END-CODE                                                                              : D10* ( ud - ud*10) D2* 2DUP D2* D2* D+ ;                      : DNEGATE ( lo hi - lo' hi')  0 0 2SWAP D- ;                    : DABS ( nd - nd)  DUP 0< IF DNEGATE THEN ;                                                                                                                                                                                                                                                                                     HEX  ( UDM*)                                                    CODE UDM*  ( ud ud - quad)  BX AX MOV,                           ( A)   BX POP, ( B) SWITCH, AX DI MOV,                          0 [BP] W-PTR MUL, ( A*C) DX PUSH, AX PUSH,  DI AX MOV,          2 [BP] W-PTR MUL, ( A*D) DX PUSH, AX PUSH,  BX AX MOV,          0 [BP] W-PTR MUL, ( B*C) DX PUSH, AX PUSH,  BX AX MOV,          2 [BP] W-PTR MUL, ( B*D) SWITCH, ( now add partials)            DI POP, DI POP, CX CX SUB, AX PUSH, ( 1st  column of product)   DX 0 [BP] ADD, 6 [BP] DX MOV, DX 2 [BP] ADC, CX 0A [BP] ADC,     4 [BP] DX MOV, 0 [BP] DX ADD, DX PUSH, ( 2nd column)            8 [BP] DX MOV, 2 [BP] DX ADC, DX PUSH, ( 3rd column)           0A [BP] CX ADC, CX PUSH, ( 4th column) 0C #, BP ADD, ( clean)   ( up ret.stk)   BX POP, ( for Pygmy's tos)                      NXT,  END-CODE                                                                                                                                                                                 ( Quad add & subtract )                                         CODE Q+ ( q q - q)                                                ( q2h in BX) CX POP, ( q2m) DX POP, ( q2m1) AX POP, ( q2l)      SWITCH, AX 6 [BP] ADD, DX 4 [BP] ADC, CX 2 [BP] ADC,              BX 0 [BP] ADC,  SWITCH,  BX POP, ( tos) NXT, END-CODE       CODE Q- ( q q - q)                                                ( q2h in BX) CX POP, ( q2m) DX POP, ( q2m1) AX POP, ( q2l)      SWITCH, AX 6 [BP] SUB, DX 4 [BP] SBB, CX 2 [BP] SBB,              BX 0 [BP] SBB,  SWITCH,  BX POP, ( tos) NXT, END-CODE                                                                       : Q0< ( nq - f) 0< PUSH DROP 2DROP POP ;                        : Q0= ( q - f) OR OR OR 0= ;                                    : QU< ( uq uq - f) Q- Q0< ;                                     : QNEGATE ( quad - quad') 0 0 0 0 4SWAP Q- ;                    : QABS ( nq - uq)  DUP 0< IF QNEGATE THEN ;                                                                                     ( signed double & mixed multiply)                                                                                               : DM* ( nd nd - nq)                                                 2PUSH DUP 0< DUP PUSH IF DNEGATE THEN                           POP 2POP DUP 0< DUP PUSH IF DNEGATE THEN ROT PUSH               UDM* 2POP XOR 0< IF QNEGATE THEN ;                                                                                          : UD* ( ud ud - ud) UDM* 2DROP ;                                                                                                : D*  ( nd nd - nd) DM* 2DROP ;                                                                                                                                                                 : D10*+ ( ud a c - ud a)                                          -DIGIT SWAP 2PUSH BASE @ 0 UD*  POP 0 D+  POP  ;                                                                                                                                              ( DOUBLE input)                                                 VARIABLE DPL ( location of decimal point from right)            VARIABLE HYPHEN  ( flag for 32nds )                                                                                             ( Above are -1 when no decimal point or hyphen is present in )  ( the number.  For the hyphen to be recognized as a hyphen, it) ( must be present in other than the 1st position or it is )     ( merely treated as a minus sign.  Most people will have no use)( for this - I needed it for some bond calculations - so just)  ( ignore it.)                                                                                                                                                                                                                                                                                                                                                                                                                                                   ( DNUMBER )                                                     : DNUMBER ( a - nd)                                               DPL ON  HYPHEN ON  BASE @ PUSH COUNT ( a #)                     OVER C@ 45 = DUP PUSH ( ie save sign) IF 1- 1 +UNDER THEN       OVER C@ 36 ( $) = IF 16 BASE !  1- 1 +UNDER THEN                OVER C@ 39 ( ') = IF DROP 1+ C@ 0  ( chr 0)                     ELSE                                                            ( a #) 0 0 2SWAP ( ud a #)  FOR ( ud a) C@+ ( ud a+1 c)         DUP 45 ( "-") = ( ud a c f) DUP                                 IF R@ HYPHEN ! THEN ( ud a c f)                                 SWAP DUP ( ud a f c c)  44 ( ,) = ( ud a f c f)                 OVER 46 ( .) = ( ud a f c f f)  DUP IF R@ DPL ! THEN            ( ud a f c f f) OR ROT OR ( ud a c f) IF DROP ELSE D10*+ THEN  NEXT ( ud a) DROP THEN  POP IF DNEGATE THEN                     POP BASE !  DPL @ 1+ HYPHEN @ 1+ OR NOT  IF DROP THEN  ;                                                                       (                continued )                                    : DIGIT?  ( c - f) '0 '9 BETWEEN ;  ( ** decimal only ** )      : VAL ( a # - dbl) ( more forgiving than DNUMBER )                -TRAILING 1 MAX  DPL ON HYPHEN ON  DUP PUSH ( a #)              FOR ( ..a) DUP R@ + C@ SWAP NEXT DROP ( put all chars on stk)   0 0 ( accum) POP FOR  ROT DUP 45 = IF DROP R@ HYPHEN !           ELSE DUP 46 = IF DROP R@ DPL ! ELSE DUP DIGIT?                 IF 15 AND PUSH D10* POP 0 D+ ELSE DROP THEN THEN THEN  NEXT ; ( ** NOTE, VAL requires the base to be decimal ** )                                                                             : D'  ( - lo hi)  ( input stream: double number string )          ( e.g.   D'  .093109404  )                                      32 WORD  DNUMBER ;                                                                                                                                                                                                                                            ( UDM/MOD )                                                     HEX                                                             CODE UDM/MOD  ( uq ud - ud-R ud-Q )                              CX CX SUB, CX DX MOV, BX AX MOV, BX POP,                        21 #, DI MOV, ( #)                                              SWITCH, CX PUSH, CX PUSH,  ( q on ret.stk)                      BEGIN, SWITCH,                                                  1 #, 2 [BP] W-PTR SHL, 1 #, 0 [BP] W-PTR RCL, SWITCH,            AX 0 [BP] CMP,  0=, IF, BX 2 [BP] CMP, 0=, IF, CX 4 [BP] CMP,   0=, IF,  DX 6 [BP] CMP,   THEN, THEN, THEN,                     U<, NOT, IF, ( if dividend >= divisor)                          SWITCH, ( 6) 2 [BP] W-PTR INC, ( lsb=1) SWITCH, DX 6 [BP] SUB,    CX 4 [BP] SBB, BX 2 [BP] SBB, AX 0 [BP] SBB, ( dend-isor)     THEN, 1 #, AX SHR, 1 #, BX RCR, 1 #, CX RCR, 1 #, DX RCR,       ( isor/2) DI DEC,  0=, UNTIL, ( step thru 33 times )          ( ** continued on next screen ** )                              (                continued )                                    HEX                                                              AX POP, BX POP, ( clean ret.stk) SWITCH,                        DX POP, DX POP, ( dend is remainder) BX PUSH, AX PUSH, ( q)     BX POP, ( for Pygmy's tos)                                     NXT, END-CODE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ( UDM/  DM/MOD  )                                               : UDM/ ( uq ud - udQ) UDM/MOD 2SWAP 2DROP ;                     : DM/MOD ( nq nd - nq-R nq-Q)                                       2PUSH DUP 0< DUP ( f-dividend-neg)                                  PUSH IF QNEGATE THEN                                        POP 2POP DUP 0< DUP ( f-divisor-neg)                                PUSH IF DNEGATE THEN ROT PUSH                               UDM/MOD 2POP OVER PUSH XOR 0< IF DNEGATE THEN                   POP IF ( dividend was neg) 2PUSH DNEGATE 2POP THEN ;            ( rounded to zero)                                                                                                                                                                                                                                                                                                                                                                                                                                          ( convert from one precision to another )                       : S->D  ( n - nd) DUP 0<  ;                                     : S->Q  ( n - nq) DUP 0< DUP DUP ;                              : D->Q  ( nd - nq) DUP 0< DUP ;                                 : Q->D  ( nq - nd) 2DROP ;                                        ( warning, Q->D doesn't test for losing significant digits)   : UD/MOD ( ud ud - udR udQ) 2PUSH 0 0 2POP UDM/MOD ;            : UD/ ( ud ud - udQ) UD/MOD 2SWAP 2DROP ;                       : D/MOD ( nd nd - ndR ndQ)  2PUSH D->Q 2POP ( nq nd)                    DM/MOD ( ndR ndQ) ;                                     : D/ ( nd nd - nd) D/MOD 2SWAP 2DROP ;                          : DMOD ( nd nd - nd) D/MOD 2DROP  ;                             : DM/ ( nq nd - nd)  DM/MOD 2SWAP 2DROP ;                       : DM*/ ( nd u1 u2 - nd) PUSH 0 DM* POP 0 DM/ ( q interm.)  ;    : UDM*/ ( ud u1 u2 - ud) PUSH 0 UDM* POP 0 UDM/ ( q interm.)  ; : D*/ ( nd nd1 nd2 - nd) 2PUSH DM* 2POP  DM/ ( q interm.)  ;    ( DOUBLE output )                                               : HOLD ( ..# lo hi c - .. c # lo hi)  2SWAP PUSH 1+ PUSH SWAP        POP SWAP POP SWAP ; ( tuck char underneath count )         : <# ( nd - ..# nd)   0 ROT ROT  ;                              : #> ( ..# nd)   2DROP FOR EMIT NEXT ;                          : SIGN  (  ..# nd n - ..# nd)  0< IF  45 HOLD   THEN ;          : # ( .# nd - .# nd) BASE @ 0 UD/MOD 2SWAP DROP DIGIT HOLD ;    : #S  ( ..# nd - ..# 0 0)  BEGIN  #  2DUP D0= UNTIL  ;          : (D.) ( nd - ..# nd) DUP PUSH DABS <# #S POP SIGN ;            : D. ( nd)    (D.) #> SPACE ;                                   : D.R ( nd n) PUSH (D.) 2DROP POP OVER - SPACES 0 0 #> ;        : D0.R ( ud #) PUSH <# POP 1- FOR # NEXT #S #> ;                : UD.R ( ud n) PUSH <# #S  2DROP POP OVER - SPACES 0 0 #> ;     : UD. ( ud)   0 UD.R  SPACE  ;                                  : UD..R ( ud #chars #decimals -) SWAP 2PUSH <# POP                FOR # NEXT  '. HOLD #S 2DROP POP OVER -  SPACES  0 0 #>  ;    ( some double formats )                                         : UD..R% ( ud # #dec -) -2 +UNDER  UD..R ."  %"  ;              : ., ( ud -)   <#   BEGIN 2DUP ( 999) BASE @ DUP DUP * * 1-        0 ( ie more than 3 places ) DU>                                WHILE  # # # 44 HOLD REPEAT  #S  32 HOLD  #> ;                : .. ( ud -)  0 8 UD..R ;                                       : ..% ( ud -) 0 6 UD..R ;                                       : .$, ( ud -)   <#   BEGIN 2DUP ( 999) BASE @ DUP DUP * * 1-       0 ( ie more than 3 places ) DU>                                WHILE  # # # 44 HOLD REPEAT  #S  32 HOLD 36 HOLD #> ;         : .$,cents ( ud -) <#  32 HOLD # # 46 HOLD BEGIN 2DUP 999 0 DU>   WHILE # # # 44 HOLD REPEAT #S  36 HOLD #> ;                   : .LOG ( ud-mantissa  n-characteristic) 3 .R                      <#  9 FOR # NEXT  46 HOLD #> ;                                                                                                                                                                ( some double formats  - continued)                             : .,centsR ( ud u -) ( right justify )  PUSH                      <#  # # 46 HOLD BEGIN 2DUP 999 0 DU>                            WHILE # # # 44 HOLD REPEAT #S  2DROP POP OVER - SPACES          0 0   #> ;                                                    : .,cents  ( ud -)  0 .,centsR ;                                                                                                : ..%R ( ud # -) ( right justify)  6 UD..R  ;                   : ..%R.3 ( ud # -) ( right justify & round to 3 places) PUSH      500 0 D+ 1000 0 UD/  POP  3 UD..R%  ;                         : ..%R.5 ( ud -) ( right justify & round to 5 places) PUSH        5 0 D+ 10 0 UD/  POP  5 UD..R%  ;                                                                                                                                                                                                                                                                                             ( dlit  DLITERAL  )                                                                                                             CODE dlit ( d -) BX PUSH, AX LODS, AX BX MOV, AX LODS, AX PUSH,      NXT,  END-CODE                                             COMPILER                                                         : DLITERAL ( d | n -) COMPILE dlit 2,  ;                        : ?LITERAL ( d | n -) DPL @ 1+ IF \ DLITERAL                      ELSE  \ SLITERAL  THEN  ;   ' ?LITERAL IS LITERAL            FORTH                                                           ' DNUMBER IS NUMBER                                                                                                                                                                                                                                                                                                                                                                                                                                             (  >>  <<    multi-place right & left double shifts )           CODE >>  ( ud n - ud/2^n)                                         BX CX MOV, ( count)  BX POP, ( msw)  AX POP, ( lsw)             CXNZ, IF,                                                         BEGIN,   1 #, BX SHR,   1 #, AX RCR,   LOOP,                  THEN,                                                           AX PUSH,   NXT,   END-CODE                                                                                                    CODE <<  ( ud n - ud*2^n)                                         BX CX MOV, ( count)                                             BX POP, ( msw)  AX POP, ( lsw)                                  CXNZ, IF,                                                         BEGIN,   1 #, AX SHL,   1 #, BX RCL,   LOOP,                  THEN,                                                           AX PUSH,   NXT,   END-CODE                                    : D2^  ( n - d2^n) 1 0 ROT  <<  ;                               HEX   ( Q* using MUL instruction, could replace w/ QM* 4DROP )  CODE Q* ( quad quad - quad)                                      BX PUSH, SWITCH,  0E [BP] BX MOV, 2 [BP] AX MOV, BX MUL,        ( b0*a2) DX CX MOV, AX PUSH,  0 [BP] AX MOV, BX MUL, ( a3*b0)   AX CX ADD, 0C [BP] BX MOV, 4 [BP] AX MOV, BX MUL, ( b1*a1)      DX CX ADD, AX PUSH, 2 [BP] AX MOV, BX MUL, ( a2*b1) AX CX ADD,  0A [BP] BX MOV, 6 [BP] AX MOV, BX MUL, ( b2*a0) DX CX ADD,      AX DI MOV, 4 [BP] AX MOV, BX MUL, ( b2*a1) AX CX ADD,           6 [BP] BX MOV, 8 [BP] AX MOV, BX MUL, ( b3*a0) AX CX ADD,       AX POP, AX DI ADD, 0 #, CX ADC, AX POP, AX DI ADD, 0 #, CX ADC, 0C [BP] AX MOV, BX MUL, ( b1*a0) DX DI ADD, 0 #, CX ADC,        AX PUSH, 0E [BP] BX MOV, 4 [BP] AX MOV, BX MUL, ( a1*b0)        DX DI ADD, 0 #, CX ADC, DX POP, DX AX ADD, AX PUSH,             0 #, DI ADC, 0 #, CX ADC, 6 [BP] AX MOV, BX MUL, ( b0*a0)       BX POP, DX BX ADD, 0 #, DI ADC, 0 #, CX ADC, 10 #, BP ADD,      SWITCH, AX PUSH, BX PUSH, DI PUSH, CX BX MOV, NXT, END-CODE    ( Q<  )                                                         CODE Q< ( l1 m1 m1 h1 l2 m2 m2 h2 - f)                            AX POP, DX POP, CX POP,  SWITCH,                                CX 6 [BP] SUB, DX 4 [BP] SBB, AX 2 [BP] SBB, BX 0 [BP] SBB,     0 #, BX MOV, <, IF, BX DEC, THEN,                               8 #, BP ADD, SWITCH,  NXT, END-CODE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ( Some macros to make following assembly easier            )    ( note: offset & a & b refer to offsets to the [BP] reg    )    ( the PUSH POP are Forth Rstk words and not asm PUSH, POP, )                                                                    ( e.g.  8 SHWL, becomes  8 [BP] W-PTR SHL,                 )    (    4 8 ADCW, becomes  4 [BP] AX MOV,  AX 8 [BP] ADC,     )                                                                    : SHWL, ( offset -) PUSH 1 #, POP [BP] W-PTR SHL, ;             : RCWL, ( offset -) PUSH 1 #, POP [BP] W-PTR RCL, ;             : SHWR, ( offset -) PUSH 1 #, POP [BP] W-PTR SHR, ;             : RCWR, ( offset -) PUSH 1 #, POP [BP] W-PTR RCR, ;             : SUBW, ( a b -) SWAP PUSH [BP] AX MOV, AX POP [BP] SUB, ;      : SBBW, ( a b -) SWAP PUSH [BP] AX MOV, AX POP [BP] SBB, ;      : ADDW, ( a b -)  PUSH [BP] AX MOV, AX POP [BP] ADD, ;          : ADCW, ( a b -)  PUSH [BP] AX MOV, AX POP [BP] ADC, ;                                                                          ( UQM/MOD )                                                     CODE UQM/MOD  ( uoctal uq - uq-R uq-Q )                           DX POP, AX POP, DI POP, ( save 4 ms words of divisor)          CX CX SUB, CX PUSH, CX PUSH, CX PUSH, CX PUSH, ( tuck zeroes)     ( extend divisor to octal, "shifting" left 4 words)            DI PUSH, AX PUSH, DX PUSH, BX PUSH, ( put back 4 ms words)     65 #, DI MOV, ( #)                                              SWITCH, CX PUSH, CX PUSH, CX PUSH, CX PUSH, ( q on ret.stk)     BEGIN, SWITCH,  6 SHWL, 4 RCWL, 2 RCWL, 0 RCWL, ( Q*2) SWITCH,   30 14 SUBW, 28 12 SBBW, 26 10 SBBW, 24 8 SBBW, 22 6 SBBW,       20 4 SBBW, 18 2 SBBW, 16 0 SBBW, ( dividend minus divisor)     CS, IF, ( a borrow means we should not have subtracted)          14 30 ADDW, 12 28 ADCW, 10 26 ADCW, 8 24 ADCW, 6 22 ADCW,       4 20 ADCW, 2 18 ADCW,  0 16 ADCW, ( dividend plus divisor)                                                                                                                                    ( UQM/MOD  continued )                                           ELSE,                                                             SWITCH,  6 [BP] W-PTR INC, ( make Q's lsb=1) SWITCH,          THEN,                                                               0 SHWR, 2 RCWR, 4 RCWR, 6 RCWR, 8 RCWR, 10 RCWR,               12 RCWR, 14 RCWR,  ( shift divisor right)                     DI DEC,                                                          0=, NOT, IF, (  UNTIL, ( step thru 65 times )                     ( addr addr) SWAP JMP,                                        THEN,  ( can't use UNTIL, above - as out of range )             24 #, BP ADD, ( drop 8 words of d'sor & 4 words of d'end)       BX POP, AX POP, DX POP, CX POP, ( get Q off Rstk)              SWITCH, CX PUSH, DX PUSH, AX PUSH, ( & put on Stk)            NXT, END-CODE                                                                                                                                                                                   EXIT          Explanation of UQM/MOD algorithm                    1st extend divisor from 4 words to 8 by tucking zeroes under  original divisor.  This also has effect of shifting it right 4  words.  Push 4 words of zeroes on Rstk for quotient.                   lsw                   msw  lsw                  msw TOS           U  U  U  U  U  U  U  U    0  0  0  0  V  V  V  V       offset= 30 28 26 24 22 20 18 16   14 12 10  8  6  4  2  0          The classical, bit by bit long division is done.              Do the following 65 times                                         1. Shift Q left by 1 bit to make room for next ls bit.          2. Subtract the divisor (as shifted) from dividend.             3a. If a borrow occurs, it wouldn't "go," so add divisor back      to restore.                                                  3b. If no borrow, increment (turn on) Quotient's ls bit.        4. Shift divisor right by 1 bit.  Go to #1.                   Clean up stacks & put results in correct place.                ( Octal division & negation)                                    CODE OCT- ( octal1 octal2 - octal1-octal2)                        BX PUSH,  8 #, CX MOV, 14 #, DI MOV, SWITCH, CLC, ( for sbb,)   BEGIN,  SS: 0 [BP+DI] AX MOV,   SS: AX 16 [BP+DI] SBB,                  DI DEC, DI DEC,                                         LOOP,  16 #, BP ADD, ( drop minuend) SWITCH, BX POP, NXT,      END-CODE                                                       CODE OCT+ ( octal1 octal2 - octal1+octal2)                        BX PUSH,  8 #, CX MOV, 14 #, DI MOV, SWITCH, CLC, ( for adc,)   BEGIN,  SS: 0 [BP+DI] AX MOV,   SS: AX 16 [BP+DI] ADC,                  DI DEC, DI DEC,                                         LOOP,  16 #, BP ADD, ( drop minuend) SWITCH, BX POP, NXT,      END-CODE                                                       : 8NEGATE ( octal - octal) 4PUSH 4PUSH                            0 0 0 0 0 0 0 0 4POP 4POP  OCT- ;                                                                                             ( signed division of an octal by a quad)                        : QM/MOD ( noctal nq - nq-R nq-Q)                                   4PUSH DUP 0< DUP ( f-dividend-neg)                                  PUSH IF 8NEGATE THEN                                        POP 4POP DUP 0< DUP ( f-divisor-neg)                                PUSH IF QNEGATE THEN  2PUSH ROT 2POP ROT PUSH               UQM/MOD 2POP OVER PUSH XOR 0< IF QNEGATE THEN                   POP IF ( dividend was neg) 4PUSH QNEGATE 4POP THEN ;            ( rounded to zero)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          EXIT           UQM*  data structure description                  A3 is most significant word and A0 is least for operand A       B3 is most significant word and B0 is least for operand B       top of stack will be shown on the _left_                                                                                       input format                                                      A3  A2  A1  A0  B3  B2  B1  B0                                working format                                                    0   2   4   6   8  10  12  14  16  18  20  22  23  24  25  26   A3  A2  A1  A0  B3  B2  B1  B0  C7  C6  C5  C4  C3  C2  C1  C0                                                                B is the multiplier and A is the multiplicand.                  The strategy is B0 * (A3,A2,A1,A0) + B1 * (A3,A2,A1,A0) etc                                                                     then the operands A & B will be dropped, leaving the product C                                                                  EXIT           UQM*  structure of the routine                   CX is outer loop counter, one pass for each of B0, B1, B2, & B3 DI is inner loop counter only                                   BP is initially bumped by 6, and                                SI is initially set to 8, and DI to 4, thus at the 1st pass      of outer loop,   0 [BP+SI] is B0                                                   0  [BP] is A0                                                16 [BP+SI] is C0.                               Then, during each pass of the inner loop, BP is decremented by 2 to alter the Ax and Cx positions, and DI is decremented by 1  as the loop counter.  Near end of outer loop, BP is incremented by 8 to restore it to point to A0 again, and SI is decremented  by 2 to pick up the next B operand and allow the proper adjust- ment of the Cx destinations.                                                                                                                                                                    ( UQM*  to work w/ separate stack segments)                     CODE UQM* ( b0 b1 b2 b3 a0 a1 a2 a3 - c0 c1 c2 c3 c4 c5 c6 c7)              AX POP, CX  POP, DX  POP,                  SWITCH,    DX PUSH, CX PUSH, AX PUSH, BX PUSH,                  SWITCH,    BX POP, AX POP,  CX  POP, DX  POP,                              DI DI SUB, DI PUSH, DI PUSH, DI PUSH, DI PUSH, ( 4 zero words)             DI PUSH, DI PUSH, DI PUSH, DI PUSH, ( & 4 more)      DX PUSH, CX PUSH, AX PUSH, BX PUSH,                  SWITCH,    BX POP, AX POP,  CX  POP, DX  POP,                   SWITCH,    DX PUSH, CX PUSH, AX PUSH, BX PUSH,                            ( above puts 8 zeroes underneath the original operands, thus:)  ( b0 b1 b2 b3 a0 a1 a2 a3 0 0 0 0 0 0 0 0)                       SWITCH,  ( so we can address the operands via [BP] )            SI PUSH, ( save IP on temp. stack)                               6 #, BP ADD, ( bump by 6 to point to A0)                        8 #, SI MOV,  4 #, CX MOV, ( outerloop counter) ( continued) ( UQM*  to work w/ separate stack segments, continued)            BEGIN, ( outer)                                                   4 #, DI MOV, ( innerloop counter)                               0 [BP+SI] PUSH,  ( save curr. multiplier, ie Bj)                BEGIN, ( inner)  AX POP, AX PUSH, ( get multiplier)              W-PTR  0 [BP] W-PTR MUL,  ( ie Bj times Ai)                          AX  16 [BP+SI] ADD, ( add into C[i+j] )                         DX  14 [BP+SI] ADC, ( add into next higher position)       W-PTR 0 #, 12 [BP+SI] ADC, (  ditto for carries)                W-PTR 0 #, 10 [BP+SI] ADC, (  ditto for carries)                W-PTR 0 #,  8 [BP+SI] ADC, (  ditto for carries)                    BP DEC, BP DEC, 1 #, DI SUB, ( we need carry flag)         0=, UNTIL,  8 #, BP ADD,  SI DEC, SI DEC,  AX POP, ( old Bj)  LOOP,  10 #, BP ADD,  SI POP,  SWITCH, BX POP, NXT,           END-CODE                                                                                                                        ( new QM*  based on UQM* )                                      : QM* ( b0 b1 b2 b3 a0 a1 a2 a3 - c0 c1 c2 c3 c4 c5 c6 c7)        4OVER Q0< PUSH 4DUP Q0< PUSH QABS 4SWAP QABS                    UQM*                                                            2POP XOR ( true if signs were different)                        IF  8NEGATE  THEN  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          : Q->OCT ( q q q q - o o o o o o o o) DUP 0< DUP DUP DUP ;      : OCT0= ( ....) OR OR OR OR OR OR OR 0= ;                                                                                       : UQ/MOD ( uq uq - uqR uqQ) 4PUSH 0 0 0 0 4POP UQM/MOD ;        : UQ/ ( uq uq - uqQ) UQ/MOD 4SWAP 4DROP ;                       : Q/MOD ( nq nq - nqR nqQ) 4PUSH Q->OCT 4POP ( n-oct nq)          QM/MOD ;                                                      : Q/ ( nq nq - nqQ) Q/MOD 4SWAP 4DROP ;                         : QMOD ( nq nq - nqR) Q/MOD 4DROP ;                             : QM/ ( n-oct nq - nqQ) QM/MOD 4SWAP 4DROP ;                    : QM*/ ( nq u1 u2 - nq) PUSH 0 0 0 QM* POP 0 0 0 QM/ ;          : Q*/ ( nq nq1 nq2 - nq) 4PUSH QM* 4POP  QM/  ;                 ( both QM*/ & Q*/ have an octal intermediate )                                                                                                                                                                                                                  : 4! ( lsw w w msw addr - )  DUP PUSH 2!  POP 4 + 2! ;          : 4@ ( addr - lsw w w msw )  DUP PUSH 4 + 2@ POP 2@ ;           : 4, ( lsw mid mid msw -)  2, 2, ;                              : 4VARIABLE ( -) 2VARIABLE 0 , 0 , ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ( QUAD output   )                                               : HOLD ( ..# quad c - .. c # quad)  2SWAP 2PUSH 2SWAP 2PUSH        SWAP POP 1+ SWAP 2POP ROT POP SWAP ; ( tuck char under #)    : <# ( nq - ..# nq)  0  SWAP 2SWAP 2PUSH ROT SWAP 2POP ROT ;    : #> ( ..# nq)   2DROP 2DROP FOR EMIT NEXT ;                    : SIGN  (  ..# nq n - ..# nq)  0< IF  45 HOLD   THEN ;          : # ( .# nq - .# nq) BASE @                                       0 0 0 UQ/MOD 4SWAP 2DROP DROP DIGIT HOLD ;                    : #S  ( ..# nq - ..# nq)  BEGIN  #  4DUP Q0= UNTIL  ;           : (Q.) ( nq - ..# nq) DUP PUSH QABS <# #S POP SIGN ;            : Q. ( nq)    (Q.) #> SPACE ;                                   : Q.R ( nq n)                                                     PUSH (Q.) 2DROP 2DROP POP OVER - SPACES 0 0 0 0 #> ;          : UQ.R ( uq n)                                                    PUSH <# #S  2DROP 2DROP POP OVER - SPACES 0 0 0 0 #> ;        : UQ. ( uq)   0 UQ.R  SPACE  ;                                  (  >>>>   <<<<    multi-place right & left quad shifts )        CODE >>>>  ( quad n - ud/2^n)                                     BX CX MOV, ( count)  AX POP, ( msw)  BX POP, ( mid)             DI POP, ( mid)  DX POP, ( lsw)                                 CXNZ, IF,  BEGIN,                                                1 #, AX SHR,   1 #, BX RCR,  1 #, DI RCR,  1 #, DX RCR, LOOP,  THEN, DX PUSH, DI PUSH, BX PUSH, AX BX MOV,   NXT,   END-CODE                                                                  CODE <<<<  ( quad n - ud*2^n)                                     BX CX MOV, ( count)  AX POP, ( msw)  BX POP, ( mid)             DI POP, ( mid)  DX POP, ( msw)  CXNZ, IF,  BEGIN,               1 #, DX SHL,   1 #, DI RCL,  1 #, BX RCL,  1 #, AX RCL, LOOP,  THEN,  DX PUSH, DI PUSH, BX PUSH, AX BX MOV,   NXT,   END-CODE                                                                 : Q10* ( q - q*10) 1 <<<< 4DUP 2 <<<< Q+ ;                                                                                      (  QNUMBER & Q' )                                               : QNUMBER ( a - nq) COUNT  ( a #) SWAP ( # a)  DUP C@ 45 =        DUP PUSH ( ie save sign) IF -1 +UNDER 1+ THEN SWAP DPL ON       ( a #) 2PUSH 0 0  0 0 2POP ( uq a #)  FOR                       DUP C@ DUP 44 ( ",") = OVER 46 ( ".") =                         DUP IF R@ DPL ! THEN OR   IF DROP                               ELSE -DIGIT ( uq a n) SWAP ( uq n a) 2PUSH                      BASE @ 0 0 0 Q*  POP 0 0 0 Q+  POP                               ( uq a) THEN 1+ NEXT   DROP  POP IF QNEGATE THEN ;                                                                           : Q'  ( - lo hi)  ( input stream: quad number string )            ( e.g.   Q'  .093109404  )                                      32 WORD  QNUMBER ;                                                                                                            ( ** note, unlike DNUMBER, QNUMBER never returns a single! **)                                                                  ( some quad formats )                                           : Q., ( uq -)   <#   BEGIN   999 0 0 0  4OVER QU<                 ( ie more than 3 places )                                       WHILE  # # # 44 HOLD REPEAT  #S  32 HOLD  #> ;                : Q.,centsR ( nq u -) ( right justify )  PUSH                     DUP 0< PUSH  ( save sign) QABS                                  <#  # # 46 HOLD BEGIN  999 0 0 0  4OVER  QU<                    WHILE # # # 44 HOLD REPEAT #S                                   POP ( ie sign) IF  45 ( -) HOLD  THEN   4DROP                   POP OVER -  SPACES  0 0 0 0 #> ;                              : UQ..R ( uq #chars #decimals -) SWAP 2PUSH <# POP                FOR # NEXT 46 ( . ) HOLD #S 4DROP POP OVER -  SPACES            0 0 0 0  #>  ;                                                : Q..R ( nq #chars #decimals -) SWAP PUSH OVER 0< 2PUSH QABS      <# POP FOR # NEXT 46 ( . ) HOLD #S POP IF  45 ( -)  HOLD        THEN  4DROP POP OVER - SPACES 0 0 0 0 #> ;                    ( qlit    smart QLITERAL  )                                     CODE qlit ( q -) BX PUSH, AX LODS, AX BX MOV, AX LODS,             AX DX MOV, AX LODS, AX CX MOV, AX LODS, AX PUSH,  CX PUSH,      DX PUSH,  NXT,  END-CODE                                                                                                                                                                     EXIT  ( Use below to make QLITERAL smart - otherwise, use     )       (  the following screen.                                )                                                                 COMPILER                                                         : QLITERAL ( q -) DPL @ 1+ IF COMPILE qlit 4,                     ELSE  3DROP COMPILE lit ,  THEN  ;                            ' QLITERAL IS LITERAL                                          FORTH                                                           ' QNUMBER IS NUMBER                                                                                                             ( dumb QLITERAL )                                               ( so few numbers usually need to be quads, that I don't usually)( install QLITERAL & QNUMBER into LITERAL & NUMBER.  Whenever ) ( I need a quad I precede the number with Q' and use QLITERAL ) ( if it is inside a definition, eg                            ) (     : XX   [ Q' 1234567812345678 ] QLITERAL  ;              )                                                                 ( if you want the smart quad built into NUMBER & LITERAL, use ) ( the EXIT'd out definitions on preceding screen              )                                                                 COMPILER                                                         : QLITERAL ( q | n -)  COMPILE qlit 4,  ;                      FORTH                                                                                                                                                                                                                                                           ( QVAL )                                                        : QVAL ( a # - quad) ( more forgiving than QNUMBER )              -TRAILING 1 MAX  DPL ON HYPHEN ( OFF) ON  DUP PUSH ( a #)       FOR ( ..a) DUP R@ + C@ SWAP NEXT DROP ( put all chars on stk)   0 0 0 0 ( accum) POP                                            FOR  4PUSH  DUP 45 = IF DROP 4POP R@ HYPHEN !                  ( DPL !) 4PUSH ( HYPHEN ON )                                      ELSE DUP 46 = IF DROP 4POP R@ DPL ! 4PUSH ELSE DUP DIGIT?      IF 15 AND S->Q   4POP Q10* Q+  4PUSH                           ELSE DROP THEN THEN THEN  4POP  NEXT ;                                                                                         ( ** NOTE, QVAL requires that the base be decimal ** )                                                                                                                                                                                                                                                                          ( DSCALE   QSCALE  )                                            : DSCALE ( ud # - ud')                                            DPL @ 0 MAX - ( ud #)                                           ?DUP IF  DUP 0< IF NEGATE  FOR 10 0 UD/ NEXT                                  ELSE         FOR D10*    NEXT  THEN THEN ;      : QSCALE ( uq # - uq')                                            DPL @ 0 MAX - ( ud #)                                           ?DUP IF  DUP 0< IF NEGATE  FOR 10 0 0 0  Q/ NEXT                              ELSE         FOR Q10*    NEXT  THEN THEN ;      EXIT                                                            ( when # - dpl is zero, do nothing, when negative, shift rt)    ( by 10 that many times, when positive, shift left that many)   ( times.  E.g.  D' 3.73  6 DSCALE gives  3730000            )   ( # means the total final number of decimal places desired, )   ( and DPL says how many we already have                     )                                                                   (  >>>>>>>>   <<<<<<<<   multi-place right & left octal shifts) CODE <<<<<<<<  ( octal n - octal*2^n)                             BX CX MOV, ( count)  SWITCH,                                    BEGIN, 14 SHWL, 12 RCWL, 10 RCWL, 8 RCWL,                          6 RCWL, 4 RCWL, 2 RCWL, 0 RCWL,                              LOOP, SWITCH, BX POP, NXT,   END-CODE                                                                                         CODE >>>>>>>>  ( octal n - octal/2^n)                             BX CX MOV, ( count)  SWITCH,                                    BEGIN, 0 SHWR, 2 RCWR, 4 RCWR, 6 RCWR,                            8 RCWR, 10 RCWR, 12 RCWR, 14 RCWR,                            LOOP, SWITCH, BX POP, NXT,   END-CODE                                                                                         : OCT10* ( octal - octal*10) 1 <<<<<<<< 8DUP 2 <<<<<<<< OCT+ ;                                                                                                                                  