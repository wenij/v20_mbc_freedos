***  Version 2 of Forth assembler for Motorola 68HC11  ***                copyright 1989-2007  Frank C. Sergeant                                                                                Warning:                                                                                                                          All addressing modes (except inherent) now require an explicitmode indicator.  Even the extended mode requires the symbol #)  now.  In the previous version the extended mode was the default and did not need a mode indicator.                                                                                                The order of the parameters for the BRCLR, BRSET, BCLR, BSET, instructions has also changed.  Now, the mask comes before the  operand.                                                                                                                                                                                                                                                        ( load screen for 68HC11 assembler )                                                                                            I've been opening these source and shadow files as unit #12,    e.g.                                                                                                                                     " 6811ASM.SCR" 12 OPEN                                          " 6811ASM.DOW" 13 OPEN                                                                                                 Then creating an executable named ASM11.COM, or some such, for  my working version for 'HC11 code generation, e.g.                                                                                       SAVE ASM11.COM                                                                                                         If you open 6811ASM.SCR at some other unit number, you will needto change the 12002 12011 THRU to something appropriate.                                                                        variables and addressing modes                                  INTEL set this to true if running on an Intel machine or to                      false if running on a Motorola machine.                                                                        BYTES ( xxyy - yy  xx)                                          FLIP ( hhll - llhh)  reverse byte order to convert from                              big-endian to little-endian or vice versa  BYTES and FLIP are now loaded in pygmy.scr version 1.7                                                                          W, ( u -) same as , but optionally adjusts for byte order.                                                                      Mode examples:                                                  immediate            direct        indexed           extended   45 #, LDA,      $C2 DIR LDX,      3 ,X LDA,      $1234 #) LDA,  $1234 #, LDD,     7 DIR JSR,     18 ,Y LDS,      $1234 #) JSR,                                                                  inherent op codes                                                                                                               These instructions do not require any explicit operands.                                                                        The TEST, instruction is commented out, as it puts the CPU into the 16-bit counter mode until it is reset, and so is useless formost programs.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  inherent op codes  - continued                                                                                                                                                                                                                                  The opcodes in the first group are each one byte long.                                                                                                                                                                                                                                                                                                                                                                                                          The opcodes in the second group are each two bytes long.                                                                                                                                                                                                                                                                                                                                        opcode, ( xxyy | 00yy -) commas in the opcode as either one byte        or two, depending on whether the most signifcant byte           is non-zero.                                                                                                            operand, ( u mode -)                                              If mode is extended, comma in two bytes, else just one byte.                                                                  operand2, ( u mode -)                                             If mode is either extended or immediate, comma in two bytes,    else just one byte.                                                                                                           e.g.   $1234 #, LDD,    8 ,Y STS,   $0017 #) STD,  17 DIR STD,  Note, the last 2 store D instructions perform the same          function, but the 1st takes 3 bytes and the 2nd takes 2 bytes.                                                                  8-bit operands                                                                                                                                                                                                                                                                                                                                                                                                                                                  e.g.   $34 #, SUBA,    0 DIR LDA,   $50 ,Y DEC,  1234 #) LDA,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ?IN-RANGE ( distance - distance) aborts with an error message ifthe destination of the branch instruction is too far away.                                                                      In general, you would not use these branch instructions, but    would let the assembler generate them for you automatically by  usings the structured conditionals, such as                                                                                         TSTA, 0=, IF,  COUNTER #) INC,  THEN,                                                                                       But, BEWARE! the structured conditional form does not test for  the destination in-range.  Keep your routines short!                                                                                                                                                                                                            Bit instructions.                                                                                                               BRCLR, & BRSET, are conditional branch instructions that branch based on an operand's (masked) bit pattern.  They do not alter  the bits of the operand byte.  The parameters passed to this    instruction are   <destination> <mask> <operand>.  The operand  must be expressed as either a positive offset plus index        register (e.g.  7 ,X) or as a page 0 direct address             (e.g. 18 DIR).  See examples on source block.                                                                                   BCLR, & BSET, have a similar form to the BRCLR, & BRSET,        instructions, but no destination address is used.  These        instructions do affect the bits in the operand byte.                                                                            Note, the mask comes before the operand.                                                                                        Here is a table showing the value of the prebyte needed for     each addressing mode of the "weird" instructions.                                                                                    imm dir ext  ,X  ,Y                                        CPD   1A  1A  1A  1A  CD                                        LDX   00  00  00  00  CD                                        CPX   00  00  00  00  CD                                        STX   xx  00  00  00  CD                                                                                                        CPY   18  18  18  1A  18                                        LDY   18  18  18  1A  18                                        STY   xx  18  18  1A  18                                                                                                                                                                                                                                                                                                        cc stands for "condition code"                                                                                                  NOT, ( cc - opposite-cc)  inverts the condition to be tested.                                                                   These conditions, in conjunction with the words on the followingblock, allow doing such things as this in assembly language:      CS, IF,                                                          <assembly instructions to perform if carry=1>                  ELSE,                                                            <assembly instructions to perform if carry=0>                  THEN,                                                                                                                         or   BEGIN,  PORTC DIR LDA,  $1B #, CMPA,  0=, UNTIL,                                                                           Note: IF, ELSE, & THEN, are not the same as IF ELSE & THEN.                                                                     This would be a good place to put examples of using the         structured assembler words.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Here is an example of how to create a simple routine.                                                                           CODE .reg  ( save the value of 4 registers at a buffer at $8500)     $8500 DUP #) STD,                                                 2 + DUP #) STX,                                                 2 + DUP #) STY,                                                 2 +     #) STS,                                                 RTS,                                                     END-CODE  Note, the machine code is for the 'HC11, so DO NOT    try to execute .reg on the PC.                                                                                                  Here are some examples of how to write an 'HC11 macro.  Think ofthese as extensions to the 'HC11 assembler & the 'HC11 instr set: PSHD, ( macro)  PSHB, PSHA,  ;                                : PULD, ( macro)  PULA, PULB,  ;                                                             THE END                            