ED.DOW   Pygmy Line Editor                                      Frank Sergeant  frank@pygmy.utoh.org                            http://pygmy.utoh.org                                                                                                           copyright 2005-2007 Frank C. Sergeant - frank@pygmy.utoh.org    BSD/MIT/X-style license, see file license20040130.txt.          http://pygmy.utoh.org                                                                                                           Similar to the one described on p. 63 ff.                       of _Starting Forth_ 2nd Ed.                                                                                                                                                                                                                                                                                                                                                                                                                                     ( Load screen for line editor)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( PLACE  utility extensions )                                                                                                   PLACE ( a # buf -) move the string to a buffer, preserving the    length count.  Buffer must be at least #+1 bytes long.                                                                        INDEX ( start end -)  show the top lines of this block range     (this is the conventional Forth INDEX )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ( Editor buffers )                                              CURSOR holds the offset (0 through 63) of the logical cursor      into the block being edited, where SCR holds the block number   of the block being edited.  Should we use a lower case x or     a vertical bar | to indicate the cursor location?  Should we    only indicate it with the single line commands such as T ?    FBUF ( - a) the find buffer, holds a counted string             IBUF ( - a) the insert buffer, holds a counted string           K ( -) swap contents of FBUF and IBUF                           LINE-TAIL ( - a #)                                               return the part of the current line from the CURSOR to the end  of the line.                                                   BLOCK-TAIL ( - a #)                                              return the part of the current block from the CURSOR to the end of the block.                                                                                                                  ( LIST  list screen with line numbers )                                                                                         .BAR                                                            .LINE#                                                          (LINE                                                           .L      show a single line with a cursor marker below                                                                           ( Here is a more complicated .L that attempts to print the)     (  cursor indicator in-line rather on the next line)                                                                            : .L ( -) CURSOR @ 64 U/MOD ( offset line)                        DUP .LINE# ( off n)                                             64 *  SCR @ BLOCK + DUP PUSH OVER TYPE '^ EMIT POP              ( off a) OVER +  64 ROT - TYPE  .BAR  ;                                                                                                                                                       ( (LIST LIST L +LIST  N  B  A  T  )                                                                                             T ( u)  make line u the current line and display it                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( SRCH  )                                                       SRCH ( - found) Search forward in the current block starting at  CURSOR, looking for the string in FBUF.                         If found, return true and also bump the CURSOR so it points     just past the matching string.  We shorten the block tail but   1 less than the length of the string we are searching for, then search up to that many chars forward for a match on the first   char of the string.  If it matches, then we do a full compare   using COMP.                                                    For efficiency, we could search for a matching first char beforechecking for a full match, e.g.                                   FBUF 1+ C@ PUSH ( -- 1stChar)                                   BLOCK-TAIL ( a #) FBUF C@ 1- -  ( a #)                          BEGIN DUP WHILE ( a #) OVER C@ R@ =                               IF ( 1stChar matched, so now do a full compare)  ...        but that's premature                                            ( (F  F  )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( SPREAD INSERT )                                               SPREAD ( a # size -)                                             insert size spaces into the string, sliding the rest of the     string forward, but maintaining its original length, thus       dropping size chars from the end of the string.                INSERT ( buf -) insert the counted string at buf into the        current line, pushing the rest of the line to the right.  This  insertion is limited to the current line.                                                                                      I can be used inside a definition so we get the                  Editor's 'I' rather than the COMPILER's 'I'?  That is, the      Editor's 'I' can be used only *outside* of definitions so       as not to conflict with the For ... Next index named 'I'.       The solution is to define '(I' so it that can be used in other  definitions and define 'I' to call '(I'.                                                                                       ( DELETE  E )                                                                                                                   DELETE ( u -)  remove u characters from the current line,        block, starting at the CURSOR, sliding chars up and filling     the end of the line with spaces.                                                                                               E ( -) delete the just-found string ( ie delete the length        of the string in FBUF before the CURSOR, so we back the         cursor up by the length of the string before DELETEing)                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ( P )                                                           BOL ( -) move cursor to beginning of current line               EOL ( -) move cursor to end of current line, ie BOL of next line                                                                P replaces the entire current line either with the string that    follows P, e.g.                                                     P NEW TEXT FOR THE LINE<Enter>                              or with the previous contents of the insert buffer IBUF if      an empty string follows follows P, eg.                              P<Enter>                                                                                                                    The cursor remains positioned on the same line (but at start)                                                                                                                                                                                                                                                                                                                                 U string                                                                                                                           U is like P except it inserts the line below the current          line and moves the remaining lines down                                                                                    C ( -)  copy current line into the insert buffer                                                                                X ( -) delete the current line, copying into insert buffer                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( S  search across blocks)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( BRING  bring a range of lines into the current block)                                                                         BRING ( sourceBlock first last -)                                 Insert the range of blocks at the current line, sliding the     current line and following lines down.  Limit the lines         brought over to those that will fit.  The source block is       not altered.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( TILL )                                                                                                                        TILL string                                                     Delete everything on current line up through string                                                                             TILL putN the deleted text into the insert buffer                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ( Pushing and Popping individual lines)                         In the Pygmy full-screen editor, CUT (F7) pushed the current    line and UNCUT (F8) popped a line into the current line.        The bufferwas at or above PAD.                                                                                                  This was convenient for copying some lines from one or          blocks into another block or blocks.  That may be easier than   using BRING which would seem to require remembering block and   line numbers.                                                                                                                   However, the stack could be used to remember those for us.  E.g.when you are looking at block 8019 and decide you want lines    3 through 6, type  8019 3 6 and then move to the destination    block with N or B or xxx LIST and then say .S to verify the     source block and line range are still there.                                                                                    ( HOLES  insert one or more blank blocks after current block)                                                                   HOLES ( u -)  spread open current block file to insert u new      blank blocks following the current block, moving the            remaining blocks down ( ie toward the end of the file).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       